import fs from 'node:fs';
import path from 'node:path';
import { spawn } from 'node:child_process';

import { getLatestTaskSpec } from '../db/taskspecs';
import { insertTaskEvent } from '../db/task-events';
import {
  attachPrToTaskById,
  getTaskById,
  updateTaskStatusById,
} from '../db/tasks-v2';
import { getProjectKnowledge } from '../db/project-settings';
import { listProjectContacts, listProjectLinks } from '../db/project-links';
import { AsanaClient } from '../integrations/asana';
import { GithubClient } from '../integrations/github';
import { logger } from '../logger/logger';
import { getProjectSecretPlain } from './project-secure-config';
import { buildProjectContextMarkdown } from './project-context';
import { buildPrLinkedAsanaComment, getOpenCodeProjectConfig } from './opencode-runner';

const MAX_OUTPUT_CHARS = 20_000;
const DEFAULT_COMMIT_PREFIX = 'opencode:';

export async function processOpenCodeRunJob(params: { projectId: string; taskId: string }): Promise<void> {
  const task = await getTaskById(params.taskId);
  if (!task || task.project_id !== params.projectId) return;
  if (task.status === 'AUTO_DISABLED' || task.status === 'CANCELLED') return;
  if (task.github_pr_number) return;

  const opencodeCfg = await getOpenCodeProjectConfig(params.projectId);
  if (opencodeCfg.mode !== 'server-runner') return;

  const workspaceRoot = opencodeCfg.workspaceRoot;
  if (!workspaceRoot) {
    await markTaskFailed(params.projectId, task, 'Missing OPENCODE_WORKSPACE_ROOT');
    return;
  }

  const openAiKey = await getProjectSecretPlain(params.projectId, 'OPENAI_API_KEY');
  if (!openAiKey) {
    await markTaskFailed(params.projectId, task, 'Missing OPENAI_API_KEY');
    return;
  }

  const ghToken = await getProjectSecretPlain(params.projectId, 'GITHUB_TOKEN');
  if (!ghToken) {
    await markTaskFailed(params.projectId, task, 'Missing GITHUB_TOKEN');
    return;
  }

  const repoOwner = task.github_repo_owner;
  const repoName = task.github_repo_name;
  const issueNumber = task.github_issue_number;
  if (!repoOwner || !repoName || !issueNumber) {
    await markTaskFailed(params.projectId, task, 'Missing repo or issue metadata');
    return;
  }

  await updateTaskStatusById(task.id, 'ISSUE_CREATED');
  await insertTaskEvent({
    taskId: task.id,
    kind: 'opencode.run_started',
    eventType: 'opencode.run_started',
    source: 'system',
    refJson: { issueNumber, repo: `${repoOwner}/${repoName}` },
  });

  const gh = new GithubClient(ghToken, repoOwner, repoName);
  const repoInfo = await gh.getRepository();
  const defaultBranch = repoInfo.default_branch || 'main';

  const runId = Date.now();
  const workspaceBase = path.join(workspaceRoot, `${repoOwner}-${repoName}`);
  const workspaceDir = path.join(workspaceBase, `issue-${issueNumber}-${runId}`);

  try {
    await fs.promises.mkdir(workspaceBase, { recursive: true });

    const tokenUrl = buildTokenRemote(repoOwner, repoName, ghToken);
    await runCommand('git', ['clone', '--depth', '1', '--branch', defaultBranch, tokenUrl, workspaceDir], {
      cwd: workspaceBase,
      scrub: ghToken,
    });

    const branchName = `opencode/issue-${issueNumber}-${runId}`;
    await runCommand('git', ['checkout', '-b', branchName], { cwd: workspaceDir });

    const prompt = await buildOpenCodePrompt({
      projectId: params.projectId,
      taskId: task.id,
      issueNumber,
      issueUrl: task.github_issue_url,
      repo: `${repoOwner}/${repoName}`,
    });

    const opencodeArgs = ['run'];
    if (opencodeCfg.model) {
      opencodeArgs.push('--model', opencodeCfg.model);
    }
    opencodeArgs.push(prompt);

    await runCommand('opencode', opencodeArgs, {
      cwd: workspaceDir,
      env: {
        OPENAI_API_KEY: openAiKey,
        OPENCODE_CONFIG_CONTENT: JSON.stringify({ permission: 'allow' }),
        OPENCODE_DISABLE_AUTOUPDATE: '1',
        OPENCODE_DISABLE_PRUNE: '1',
      },
    });

    const status = await runCommand('git', ['status', '--porcelain'], { cwd: workspaceDir });
    if (!status.stdout.trim()) {
      await markTaskFailed(params.projectId, task, 'OpenCode produced no changes');
      return;
    }

    await runCommand('git', ['add', '-A'], { cwd: workspaceDir });
    await runCommand(
      'git',
      ['-c', 'user.name=opencode-bot', '-c', 'user.email=opencode@local', 'commit', '-m', buildCommitMessage(task.title, issueNumber)],
      { cwd: workspaceDir },
    );

    await runCommand('git', ['push', tokenUrl, branchName], { cwd: workspaceDir, scrub: ghToken });

    const pr = await gh.createPullRequest({
      title: task.title ? task.title : `OpenCode: Issue #${issueNumber}`,
      body: `Fixes #${issueNumber}\n\nGenerated by OpenCode server runner.`,
      head: branchName,
      base: defaultBranch,
    });

    await attachPrToTaskById({ taskId: task.id, prNumber: pr.number, prUrl: pr.html_url, sha: pr.head_sha });
    await updateTaskStatusById(task.id, 'PR_CREATED');

    await insertTaskEvent({
      taskId: task.id,
      kind: 'task.status_changed',
      eventType: 'task.status_changed',
      source: 'system',
      refJson: { from: task.status, to: 'PR_CREATED', reason: 'opencode.server_runner' },
    });

    await insertTaskEvent({
      taskId: task.id,
      kind: 'github.pr_created',
      eventType: 'github.pr_created',
      source: 'system',
      refJson: { prNumber: pr.number, prUrl: pr.html_url, headSha: pr.head_sha },
    });

    const asanaPat = await getProjectSecretPlain(params.projectId, 'ASANA_PAT');
    if (asanaPat) {
      const asana = new AsanaClient(asanaPat);
      const comment = buildPrLinkedAsanaComment({ prUrl: pr.html_url, issueUrl: task.github_issue_url });
      try {
        await asana.addComment(task.asana_gid, comment);
        await insertTaskEvent({
          taskId: task.id,
          kind: 'asana.comment_posted',
          eventType: 'asana.comment_posted',
          source: 'system',
          message: comment,
          refJson: { prNumber: pr.number, prUrl: pr.html_url },
        });
      } catch (err: any) {
        await insertTaskEvent({
          taskId: task.id,
          kind: 'asana.comment_failed',
          eventType: 'asana.comment_failed',
          source: 'system',
          message: String(err?.message ?? err),
          refJson: { prNumber: pr.number, prUrl: pr.html_url },
        });
      }
    }
  } catch (err: any) {
    logger.error({ err, taskId: task.id }, 'OpenCode server runner failed');
    await markTaskFailed(params.projectId, task, String(err?.message ?? err));
  }
}

async function buildOpenCodePrompt(params: {
  projectId: string;
  taskId: string;
  issueNumber: number;
  issueUrl: string | null;
  repo: string;
}): Promise<string> {
  const spec = await getLatestTaskSpec(params.taskId);
  const taskSpec = spec?.markdown ?? 'No TaskSpec found.';

  const ctx = buildProjectContextMarkdown({
    knowledgeMarkdown: await getProjectKnowledge(params.projectId),
    links: await listProjectLinks(params.projectId),
    contacts: await listProjectContacts(params.projectId),
  });

  const lines = [
    `Repository: ${params.repo}`,
    `Issue: #${params.issueNumber}${params.issueUrl ? ` (${params.issueUrl})` : ''}`,
    '',
    'TaskSpec:',
    '```',
    taskSpec,
    '```',
  ];

  if (ctx.trim()) {
    lines.push('', 'Project Context:', '```', ctx.trim(), '```');
  }

  lines.push(
    '',
    'Instructions:',
    '- Implement the TaskSpec in this repository.',
    '- Do not commit, push, or open PRs; leave changes in the working tree.',
    '- Follow existing project conventions.',
  );

  return lines.join('\n');
}

function buildTokenRemote(owner: string, repo: string, token: string): string {
  return `https://x-access-token:${token}@github.com/${owner}/${repo}.git`;
}

async function runCommand(
  command: string,
  args: string[],
  opts: { cwd: string; env?: Record<string, string>; scrub?: string },
): Promise<{ stdout: string; stderr: string }> {
  return new Promise((resolve, reject) => {
    const proc = spawn(command, args, {
      cwd: opts.cwd,
      env: { ...process.env, ...(opts.env ?? {}) },
      stdio: ['ignore', 'pipe', 'pipe'],
    });

    let stdout = '';
    let stderr = '';

    proc.stdout.on('data', (chunk) => {
      if (stdout.length < MAX_OUTPUT_CHARS) {
        stdout += chunk.toString();
        if (stdout.length > MAX_OUTPUT_CHARS) stdout = stdout.slice(0, MAX_OUTPUT_CHARS);
      }
    });

    proc.stderr.on('data', (chunk) => {
      if (stderr.length < MAX_OUTPUT_CHARS) {
        stderr += chunk.toString();
        if (stderr.length > MAX_OUTPUT_CHARS) stderr = stderr.slice(0, MAX_OUTPUT_CHARS);
      }
    });

    proc.on('error', reject);
    proc.on('close', (code) => {
      const scrubbed = opts.scrub ? scrubOutput(stdout + stderr, opts.scrub) : null;
      const displayCommand = opts.scrub ? scrubOutput(`${command} ${args.join(' ')}`, opts.scrub) : `${command} ${args.join(' ')}`;
      if (code === 0) {
        resolve({ stdout, stderr });
        return;
      }
      const message = scrubbed
        ? `Command failed: ${displayCommand}\n${scrubbed}`
        : `Command failed: ${displayCommand}`;
      reject(new Error(message));
    });
  });
}

function scrubOutput(value: string, secret: string): string {
  if (!secret) return value;
  return value.split(secret).join('***');
}

function buildCommitMessage(title: string | null, issueNumber: number): string {
  const base = title?.trim() ? title.trim() : `Issue #${issueNumber}`;
  const trimmed = base.length > 60 ? `${base.slice(0, 57)}...` : base;
  return `${DEFAULT_COMMIT_PREFIX} ${trimmed}`;
}

async function markTaskFailed(
  projectId: string,
  task: { id: string; asana_gid: string; status?: string | null },
  message: string,
): Promise<void> {
  await updateTaskStatusById(task.id, 'FAILED', message);
  await insertTaskEvent({
    taskId: task.id,
    kind: 'opencode.run_failed',
    eventType: 'opencode.run_failed',
    source: 'system',
    message,
  });
  await insertTaskEvent({
    taskId: task.id,
    kind: 'task.status_changed',
    eventType: 'task.status_changed',
    source: 'system',
    refJson: { from: task.status ?? null, to: 'FAILED', reason: 'opencode.run_failed' },
  });

  const asanaPat = await getProjectSecretPlain(projectId, 'ASANA_PAT');
  if (asanaPat) {
    const asana = new AsanaClient(asanaPat);
    try {
      await asana.addComment(task.asana_gid, `OpenCode server runner failed: ${message}`);
    } catch (err) {
      logger.warn({ err, taskId: task.id }, 'Failed to add Asana failure comment');
    }
  }
}
