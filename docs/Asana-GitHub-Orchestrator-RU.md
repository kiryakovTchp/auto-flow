# Спецификация сервиса Asana–GitHub Orchestrator

## Обзор и цели

Разработать Node.js бэкенд-сервис (оркестратор) с базой данных PostgreSQL, который интегрирует рабочие процессы Asana и GitHub. Оркестратор будет работать на отдельном сервере и выступать в качестве диспетчера (без прямого выполнения кода). Ключевые обязанности:

- **Интеграция вебхуков с Asana**: Подписаться на события Asana (например, новые задачи, завершение задач) через вебхуки. При получении релевантных событий Asana создавать соответствующие GitHub issues.

- **Интеграция вебхуков с GitHub**: Подписаться на события GitHub (например, закрытые issues, слитые pull requests) через вебхуки. При получении релевантных событий GitHub обновлять задачи Asana (помечать как завершённые, когда код готов).

- **REST API для мониторинга и ручного запуска**: Предоставить endpoints для проверки статуса системы, списка синхронизированных задач/issues и ручного запуска действий синхронизации (например, принудительное создание GitHub issue из задачи Asana).

- **Обработка спецификаций задач**: Обеспечить передачу содержимого/спецификации задачи Asana ("TaskSpec") в GitHub issue (заголовок, описание и т.д.), сохраняя детали, необходимые для AI-агента для её реализации.

- **Полная автоматизация**: Реализовать всё с нуля – включая настройку вебхуков, схему БД, API endpoints и логику обработки жизненного цикла задач/issues – чтобы система работала end-to-end без ручного вмешательства.

- **Безопасность и надёжность**: Валидировать все вебхук-запросы (проверка сигнатуры), использовать правильную аутентификацию при вызове внешних APIs, грамотно обрабатывать ошибки и повторные попытки, логировать важные события и избежать предположений, строго следуя официальной документации API.

## Технологический стек и настройка

### Язык и фреймворк

Node.js (JavaScript или TypeScript) с HTTP-фреймворком, таким как Express, для обработки вебхук-коллбэков и REST endpoints.

### База данных

PostgreSQL для хранения отображений между задачами Asana и GitHub issues (а также другого состояния, например, секретов вебхуков или статуса обработки). Используйте переменные окружения для подключения БД (например, `PGHOST`, `PGUSER`, `PGPASSWORD`, `PGDATABASE`) и установите пул соединений. Например, используя node-postgres (`pg`):

```javascript
// Using environment variables for PostgreSQL connection
const { Pool } = require('pg');
const pool = new Pool(); // reads PGHOST, PGUSER, PGPASSWORD, PGDATABASE, etc. from env
```

Как указано в документации Node-Postgres, клиент будет использовать стандартные переменные окружения, если конфигурация не предоставлена.

Убедитесь в обработке ошибок пула и закрытии соединений при завершении сервиса.

### Конфигурация

Используйте переменные окружения для чувствительной конфигурации:

- `ASANA_PAT` – Asana Personal Access Token (для API-вызовов и настройки вебхуков).
- `GITHUB_TOKEN` – GitHub API token (Personal Access Token с доступом к репозиториям для создания issues и т.д., либо токен установки GitHub App).
- `GITHUB_WEBHOOK_SECRET` – для верификации GitHub вебхуков.
- `ASANA_PROJECT_GID` (опционально) – ID проекта Asana для мониторинга, если интегрируется только один проект.
- Учетные данные БД, как упомянуто выше.

### Внешние URLs

Сервис должен быть доступен на публичных HTTPS endpoints для вебхуков. (На этапе разработки можно использовать tools как ngrok, но в production используйте правильный домен с HTTPS). Asana откажет в вебхуках на localhost или незащищённые URLs.

## Схема БД и персистентность

Разработайте таблицу (или таблицы) для отслеживания отображений Asana–GitHub и информации о вебхуках. Например:

### Таблица отображений задач (task_mappings)

Хранит отношение между задачей Asana и GitHub issue. Поля:

- `asana_gid` (string): GID задачи Asana.
- `asana_project` (string): GID проекта Asana (если нужно убедиться, что событие в правильном проекте).
- `github_issue_number` (integer): номер GitHub issue в репозитории.
- `github_issue_id` (integer или string): ID GitHub issue (глобальный ID, опционально – номер issue обычно достаточен).
- `status` (string): статус задачи/issue ("open", "completed/closed"). Может быть получен из Asana/GitHub, но сохранение упрощает запросы.
- `created_at`, `updated_at` – временные метки для аудита.

### Таблица секретов вебхуков (опционально)

Если используется несколько вебхуков Asana (например, для нескольких проектов), сохраняйте `id` и `secret` каждого вебхука. Альтернативно, поскольку оркестратор инициирует вебхук Asana и знает секрет, он может хранить его в памяти или конфигурации.

### Таблица логирования/аудита (опционально)

Для записи полученных событий и выполненных действий в целях отладки. Можно также просто логировать в консоль или файл.

Убедитесь в создании индекса на `asana_gid` и `github_issue_number` для быстрого поиска.

Используйте **параметризованные запросы** или **ORM** для предотвращения SQL-инъекций при вставке/обновлении этих записей. Валидируйте типы данных (например, что `asana_gid` соответствует формату ID Asana – обычно это числовая строка). Весь доступ к БД должен обрабатывать ошибки (try/catch вокруг запросов с надлежащим логированием).

## Интеграция вебхуков Asana

### 1. Установка подписки на вебхук Asana

Оркестратор должен зарегистрировать вебхук на релевантном проекте Asana (или workspace), чтобы получать события задач. Это делается через endpoint Asana API "Establish a webhook":

**Запрос**: `POST https://app.asana.com/api/1.0/webhooks` с JSON-телом, содержащим:

- `resource` – GID проекта (или другого ресурса) для мониторинга.
- `target` – URL вебхук-endpoint оркестратора (например, `https://<ваш-домен>/webhooks/asana`).

Запрос должен включать Asana PAT в заголовок Authorization: `Authorization: Bearer <ASANA_PAT>`. Например:

```bash
curl -H "Authorization: Bearer $ASANA_PAT" -H "Content-Type: application/json" -X POST https://app.asana.com/api/1.0/webhooks \
-d '{
       "data": {
         "resource": "1234567890123456", 
         "target": "https://yourdomain.com/webhooks/asana"
       }
     }'
```

Asana ответит с 201 Created, если вебхук успешно инициирован. Однако вебхук полностью устанавливается только после выполнения handshake:

**Handshake**: После POST-запроса Asana немедленно отправляет запрос handshake на target URL с заголовком `X-Hook-Secret`. Оркестратор **должен** ответить с 200 OK (или 204 No Content) и **эхо-ответить** точно такой же заголовок `X-Hook-Secret`. Это подтверждает Asana, что наш сервер ожидает вебхук. Если ответить неправильно, попытка не пройдёт. Поток:

- Asana отправляет: `POST https://yourdomain.com/webhooks/asana` (без body) с заголовком `X-Hook-Secret: <случайное_значение_секрета>`.
- Оркестратор отвечает со статусом 200 и заголовком `X-Hook-Secret: <то_же_значение>`.

Пример из документации: "target должен ответить с 200 OK или 204 No Content и соответствующим заголовком X-Hook-Secret для подтверждения того, что эта подписка на вебхук ожидается."

Если нет, Asana не создаст вебхук.

**Сохранение секрета**: Asana API также включит `X-Hook-Secret` в ответ на `POST /webhooks` запрос (для безопасности, рассматривайте это как источник истины). Захватите этот секрет и сохраните его (в памяти или БД) – он будет использован для верификации входящих подписей событий. После handshake ответ Asana содержит JSON с данными вебхука (включая "gid" для вебхука) и заголовок `X-Hook-Secret: <секрет>`. Сохраните секрет вместе с ID вебхука.

**Примечание безопасности**: Первоначальный handshake-запрос не подписан (содержит только секрет). Asana рекомендует ограничивать доверие на этом этапе. Например, сгенерируйте одноразовый токен и включите его как query-параметр в `target` URL при создании вебхука, затем верифицируйте этот токен во входящем handshake-запросе. Это гарантирует, что handshake-вызов действительно связан с вашей инициацией. После установления вебхука все будущие события будут подписаны HMAC, используя секрет.

**Фильтры (опционально)**: При создании вебхука можно указать фильтры для ограничения того, какие события вы получаете. Разумно получать только релевантные события, чтобы снизить шум. Например, чтобы получать только события создания и завершения задач в проекте, вы можете включить:

```json
"filters": [
  { "resource_type": "task", "action": "added" },
  { "resource_type": "task", "action": "changed", "fields": ["completed"] }
]
```

Это будет доставлять события, когда задачи добавляются в проект или когда поле `completed` задачи меняется (true/false). По документации Asana, фильтры действуют как whitelist – событие доставляется, если оно соответствует любому фильтру.

Убедитесь, что оркестратор обрабатывает создание вебхука либо при старте, либо через script/endpoint настройки. (Может быть не идеально создавать автоматически при каждом запуске, чтобы избежать дубликатов – возможно, проверяйте, существует ли вебхук для ресурса). Если не создаётся автоматически, документируйте шаги для создания вебхука через вышеприведённый API-вызов.

### 2. Endpoint вебхука Asana (приём событий)

Реализуйте Express-роут (например, `POST /webhooks/asana`) для обработки входящих Asana webhook POST-запросов. Этот единственный endpoint должен обрабатывать два случая: первоначальный handshake и последующие доставки событий.

#### a. Обработка Handshake

Когда присутствует `req.headers['x-hook-secret']`, рассматривайте запрос как handshake-верификацию от Asana. Обработчик должен:

- Логировать получение handshake (для мониторинга).
- Вернуть ответ со статусом 200 и заголовком `X-Hook-Secret`, идентичным полученному.
- Опционально, включить простой body вроде "OK" для ясности (Asana игнорирует body).
- Сохранить секрет, если ещё не сохранён. Например, в памяти:

```javascript
const hookSecret = req.headers['x-hook-secret'];
if (hookSecret) {
  res.set('X-Hook-Secret', hookSecret);
  res.status(200).send('OK');
  saveAsanaSecret(hookSecret);
  // save to env or DB
  console.log("Asana webhook handshake completed");
  return;
}
```

Это аналогично примеру в документации Asana, который демонстрирует эхо-ответ заголовка и сохранение секрета.

#### b. Верификация сигнатуры события

Для каждого входящего события вебхука Asana (всё после handshake) Asana включает заголовок `X-Hook-Signature`. Это HMAC-SHA256 хеш тела запроса, используя секрет из handshake. Оркестратор должен верифицировать это, чтобы гарантировать, что запрос действительно от Asana и не подделан:

**Вычисление HMAC**: Прочитайте raw body запроса (Asana отправляет JSON). **Важно**: вы должны получить доступ к raw payload-байтам перед любым JSON-парсингом, потому что сигнатура вычисляется на raw-body. В Express можно использовать `app.use(express.raw({ type: 'application/json' }))` для вебхук-роута, чтобы получить `req.body` как Buffer. Альтернативно, используйте опцию `verify` в bodyParser для сохранения raw-копии.

**Получите заголовок `X-Hook-Signature`** из запроса. Если отсутствует, ответьте с 401 Unauthorized и логируйте инцидент.

**Используя Node `crypto` library**, вычислите HMAC SHA256 raw-body, используя сохранённый секрет. Конвертируйте в hex-строку. По документации Asana, сигнатура Asana – это hexadecimal-строка хеша. (Примечание: документация Asana не префиксирует это схемой вроде "sha256=", это просто hex-digest.)

**Сравните вычисленный хеш с `X-Hook-Signature`** из заголовка. Используйте constant-time сравнение для предотвращения timing-атак (например, `crypto.timingSafeEqual()` с Buffers). Если они не совпадают точно, логируйте ошибку и ответьте 401 Unauthorized. Не обрабатывайте запрос дальше, если верификация сигнатуры не пройдена.

Если сигнатура валидна, ответьте быстро с 200 OK для подтверждения получения, затем приступайте к обработке payload события. (Для производительности вы можете немедленно `res.status(200).send()` и обрабатывать логику события в отдельном async-тике, чтобы доставка вебхука не была задержана. Asana ожидает быстрого ответа; любая тяжёлая обработка должна быть async.)

Цитируя документацию Asana по сигнатуре: "Каждое событие вебхука включает X-Hook-Signature (HMAC-SHA256 над body с секретом). Верифицируйте, вычислив HMAC с сохранённым секретом и сравнив с заголовком, используя constant-time сравнение."

Ниже приведена псевдокод-иллюстрация верификации:

```javascript
const signature = req.headers['x-hook-signature'];
if (!signature) {
  res.status(401).send('Unauthorized');
  return;
}
const expected = crypto.createHmac('sha256', ASANA_SECRET).update(req.body).digest('hex');
if (!crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expected))) {
  res.status(401).send('Unauthorized');
  return;
}
// Signature OK: proceed
const eventPayload = JSON.parse(req.body);
res.status(200).send('Received');
handleAsanaEvents(eventPayload);
```

Это согласуется с примерами Asana.

#### c. Парсинг и обработка событий Asana

После верификации парсируйте JSON payload. Payload вебхука Asana имеет форму:

```json
{
  "events": [ { ...event1... }, { ...event2... }, ... ]
}
```

Несколько событий могут быть объединены в одну доставку, поэтому пройдите через каждый объект события в массиве `events`. Каждый объект события обычно содержит:

- `resource` – объект с как минимум `gid` (ID ресурса, например ID задачи) и `resource_type` (например "task"). Он может включать `name` (имя задачи) в некоторых случаях.
- `action` – строка, указывающая, что произошло – например "added", "changed", "deleted".
- `parent` – для определённых событий, родительский ресурс. Например, если задача была добавлена в проект, `parent` будет ссылаться на этот проект. Если подзадача была добавлена, `parent` может быть родительской задачей.
- `change` – (для changed событий) объект с деталями изменения: `field` (какое поле изменилось) и `new_value` и т.д. Например, когда статус завершения задачи меняется, `change.field = "completed"` и `change.new_value = true` или `false`.

**Релевантные события для обработки:**

#### Задача создана/добавлена

Это может приходить как `action: "added"` на ресурсе типа task. Например, когда новая задача создана в проекте (или существующая задача добавлена в проект). Пример payload-фрагмента:

```json
{
  "events": [
    {
      "resource": { 
        "gid": "44556677889900", 
        "resource_type": "task",
        "name": "Implement user authentication" 
      },
      "action": "added",
      "parent": { 
        "gid": "99001122334455", 
        "resource_type": "project",
        "name": "Q1 2025 Development Sprint" 
      },
      "change": null
    }
  ]
}
```

В этом случае новая задача *Implement user authentication* была добавлена в проект *Q1 2025 Development Sprint*. Оркестратор должен ответить, создав соответствующий GitHub issue (детали ниже). Используйте Asana `resource.gid` для получения полных деталей задачи (потому что payload вебхука "лёгкий" – он может не включать описание задачи и т.д.). Вы можете вызвать Asana **Get Task** API:

`GET /tasks/<task_gid>?opt_fields=name,notes,completed,...` с PAT-токеном для получения деталей вроде task notes (описание), которые могут быть использованы как body issue.

**Примечание:** Asana рекомендует делать дополнительные API-вызовы для деталей, потому что события вебхука не включают полную информацию задачи (например, нет пользовательских полей или текста описания в payload).

#### Задача завершена

Пометка задачи как завершённая инициирует `changed` событие с `change.field: "completed"`. Пример события завершения задачи:

```json
{
  "events": [
    {
      "resource": { 
        "gid": "22334455667788", 
        "resource_type": "task",
        "name": "Write unit tests for API endpoints" 
      },
      "action": "changed",
      "change": { 
        "field": "completed", 
        "action": "changed",
        "new_value": true 
      }
    }
  ]
}
```

Здесь задача *Write unit tests for API endpoints* только что была завершена (`new_value: true` означает завершено; если бы это было `false`, это указало бы, что задача была помечена как незавершённая/переоткрыта). В ответ оркестратор должен найти соответствующий GitHub issue и закрыть его (если он ещё открыт), чтобы держать их в синхронизации. Таблица отображений `task_mappings` может быть запрошена по Asana task GID для получения номера GitHub issue, затем использовать GitHub API для закрытия issue (детали в разделе GitHub ниже).

#### Другие изменения

Вы можете получить другие изменения задачи (изменения ответственного, редактирование описания, добавленные комментарии (stories) и т.д., если не отфильтрованы). По умолчанию вебхук проекта без фильтров будет отправлять много событий. Рекомендуется фильтровать события, которые не нужны для цели этого оркестратора. Например, вероятно, нам не нужно реагировать на переименование задач или переназначение (это могло бы быть синхронизировано с заголовком GitHub issue или ответственным в более продвинутой синхронизации, но это вне основной области). Если установлены фильтры, как предлагается, мы в основном получим события `task.added` и `task.changed (completed)`. Если приходит событие, которое мы не обрабатываем (например, комментарий добавлен), просто ответьте 200 и возможно логируйте для информации, но не предпринимайте никаких действий.

#### Идемпотентность

Asana может отправить одно и то же событие несколько раз или отправить "heartbeat" событие без изменений (пустой массив `events` каждые ~8 часов, чтобы убедиться, что endpoint жив). Избегайте дублирующейся обработки: используйте БД для проверки, обработали ли мы уже данное действие задачи. Например, если `task.added` приходит для задачи, которая уже в нашей таблице отображений, пропустите создание другого issue (это может быть дублирующейся доставкой). Аналогично, если `task.changed:completed:true` приходит, но наша БД или GitHub уже показывает issue как закрытый, убедитесь, что мы не делаем избыточные API-вызовы. Заголовок `X-Hook-Delivery` от Asana (если предоставлен) или комбинация полей события могут быть использованы как уникальный ключ для отслеживания обработанных событий. Логирование событий с ID/timestamp может помочь с отладкой дубликатов.

После обработки событий (вероятно, асинхронно), работа вебхук-endpoint Asana завершена.

### 3. Создание GitHub Issue из задачи Asana

Когда новое событие задачи Asana получено (задача добавлена), оркестратор должен создать GitHub Issue в сконфигурированном репозитории, который представляет эту задачу для работы AI-агента. Используйте endpoint GitHub REST API для создания issue: `POST /repos/{owner}/{repo}/issues`.

**Композиция запроса**: Включите как минимум следующие JSON-поля в тело запроса:

- `title` – Заголовок issue (используйте имя задачи Asana). Держите его кратким; имена задач Asana обычно короткие.
- `body` – Описание issue. Здесь включите детали из задачи Asana:
  - Описание задачи Asana (notes).
  - Любая релевантная информация вроде срока, тегов, или пользовательских полей, если нужно (поскольку это для code-generation, описание задачи вероятно, является prompt/spec).
  - Опционально, обратная ссылка на задачу Asana (например, URL `https://app.asana.com/0/<projectID>/<taskID>`).
  - Вы можете также добавить маркер, что этот issue был автогенерирован оркестратором, или пометить его соответственно.

- `labels` (опционально) – Вы можете пометить issue с меткой (например, "Asana" или "TaskSpec"), чтобы указать, что он пришёл из Asana, что может быть полезно для фильтрации этих issues. Примечание: Установка меток требует, чтобы PAT имел доступ push; иначе метки будут молча отброшены. Убедитесь, что токен имеет разрешение или пропустите метки, если нет.

- `assignees` (опционально) – Если есть специфический GitHub username для назначения. По умолчанию issue может остаться неназначенным или назначенным пользователю по умолчанию (возможно, maintainer проекта или bot-пользователю). Это поле опционально.

Не устанавливайте `state` здесь; новые issues будут открыты по умолчанию. Также, если используются fine-grained токены, убедитесь, что он имеет разрешение "Issues: Write".

Включите заголовок `Authorization: Bearer <GITHUB_TOKEN>` и рекомендуемый заголовок `Accept: application/vnd.github+json`. Например (cURL формат):

```bash
curl -X POST https://api.github.com/repos/OWNER/REPO/issues \
-H "Accept: application/vnd.github+json" \
-H "Authorization: Bearer $GITHUB_TOKEN" \
-d '{
  "title": "Implement user authentication", 
  "body": "From Asana: Implement user authentication...\n\nTask: https://app.asana.com/0/99001122334455/44556677889900"
}'
```

Если успешно, GitHub возвращает статус 201 с данными issue (включая номер issue). Оркестратор должен затем:

- Сохранить отображение: вставить строку в `task_mappings` с Asana task GID и новым номером GitHub issue (и любой другой информацией вроде статуса "open").
- Возможно, записать GitHub issue URL и ID. URL и номер issue приходят в ответе (например, `"html_url": "https://github.com/owner/repo/issues/42"`, `"number": 42` и т.д.).
- Логировать создание (например, "Created GitHub issue #42 for Asana task 44556677889900").

**Примечание о описаниях задач**: Убедитесь, что описание задачи Asana отформатировано в Markdown, если нужно (GitHub issues поддерживают Markdown). Если поле "notes" Asana содержит разрывы строк или списки, сохраняйте их. Также санитизируйте любой HTML, если присутствует (Asana может позволить некоторый rich text; API обычно возвращает plain text или простое форматирование, которое должно быть нормально).

**Обновления Asana**: Опционально, вы можете опубликовать комментарий в задаче Asana со ссылкой на GitHub issue, чтобы информировать пользователей (используя Asana's `POST /tasks/{id}/stories` для создания комментария). Это не было явно запрошено, но может закрыть loop UX-wise. Если реализуете, включите это как отдельный шаг после создания issue (и также используйте PAT, с коротким сообщением типа "Linked GitHub Issue: #42"). Убедитесь в обработке ошибок (отсутствие разрешения на комментирование и т.д.).

## Интеграция вебхуков GitHub

Чтобы держать Asana в синхронизации с прогрессом GitHub, установите вебхук GitHub на репозитории (где issues и PRs будут жить). Этот вебхук будет уведомлять оркестратор об релевантных событиях, таких как закрытие issue или слияние pull request. Нас конкретно интересуют:

- **События Issue** (особенно когда issue закрыт, возможно переоткрыт).
- **События Pull Request** (особенно когда PR слит, что может автоматически закрыть issue).

### Настройка вебхука

Сконфигурируйте вебхук GitHub (через UI GitHub или API). Если используется API, это `POST /repos/{owner}/{repo}/hooks` с JSON-телом, указывающим:

- `config.url` – endpoint вебхука GitHub оркестратора (например, `https://yourdomain.com/webhooks/github`).
- `config.content_type` – `"json"`.
- `config.secret` – секретный токен (это `GITHUB_WEBHOOK_SECRET`, который оркестратор будет использовать для верификации).
- `events` – массив типов событий для подписки, например `["issues", "pull_request"]`. (Также включите `"ping"` для тестирования connectivity, или просто примите ping по умолчанию.)
- `active` – `true`.

Альтернативно, установите это через GitHub settings вручную. Убедитесь, что секрет strong и держите его secure.

Оркестратор будет экспозировать `POST /webhooks/github` для получения этих событий.

### Endpoint вебхука GitHub (верификация и обработка)

#### a. Верификация сигнатуры (GitHub)

GitHub подписывает payload своих вебхуков HMAC SHA256 также, используя секрет, который вы предоставляете. Сигнатура включена в заголовок `X-Hub-Signature-256` (формат: `sha256=<hexdigest>`). Мы должны верифицировать это аналогично Asana:

- Возьмите заголовок `X-Hub-Signature-256` из запроса. Если отсутствует, ответьте 401 (вебхук может быть не сконфигурирован с секретом, если отсутствует).
- Вычислите HMAC SHA256 тела запроса (raw payload string), используя известный `GITHUB_WEBHOOK_SECRET`. Префиксируйте hex digest с `sha256=` для формирования ожидаемой строки сигнатуры.
- Используйте constant-time сравнение (`crypto.timingSafeEqual` или `crypto.createHmac(...).digest()`, затем сравните digests) для сравнения ожидаемой сигнатуры с значением заголовка. Если они отличаются, отклоните с 401. Пример из документации GitHub: "expected_signature = 'sha256=' + hmac_sha256(secret, payload_body); если не совпадает, 403".

В Node это аналогично коду, используемому для Asana (просто убедитесь в включении префикса 'sha256=' при сравнении).

GitHub также отправляет заголовок `X-GitHub-Delivery` с UUID для каждой доставки и заголовок `X-GitHub-Event`, указывающий тип события (например, "issues" или "pull_request"). Мы можем логировать это и использовать ID доставки для дедупликации, если нужно.

Помните, что Express JSON-парсер по умолчанию будет парсировать body, поэтому аналогично Asana, используйте raw body или опцию `verify` для получения raw text для верификации сигнатуры.

#### b. Логика обработки событий

После верификации сигнатуры парсируйте JSON payload. Проверьте заголовок `X-GitHub-Event` (или структуру payload) для определения типа события. Для наших нужд:

**События Issue**: События `issues` происходят при actions вроде "opened", "edited", "closed", "reopened". Нас интересуют:

- `action == "closed"` на issue. Это означает, что кто-то закрыл issue (вручную или через слитый PR или commit, ссылающийся на "Closes #issue"). Payload будет включать объект `issue`. Например, `payload.action` может быть "closed", и `payload.issue` будет иметь детали вроде `number`, `state: "closed"`, `title` и т.д. Используйте `issue.number` для поиска соответствующей задачи Asana через отображение БД (где `github_issue_number = issue.number`). Если найдена и задача Asana ещё не завершена, вызовите Asana API для пометки задачи как завершённой.

  **Asana API для пометки как завершённая**: Мы используем endpoint Update Task. Отправьте `PUT /tasks/<task_gid>` с JSON-телом `{"data": {"completed": true}}`. Asana API ожидает PUT для обновлений (не GET). В документации Asana: "Вы можете обновить задачу, сделав PUT-запрос на /tasks/{task-id} и определив поле `completed` как true."

  Это пометит задачу завершённой. Убедитесь в включении заголовка Authorization с PAT для этого запроса.

  После пометки завершённой, вы также можете хотеть добавить комментарий на задачу Asana типа "Automatically completed via PR merge" (опционально).

  Если issue был закрыт, но задача Asana уже завершена (возможно, пользователем), просто убедитесь в consistency (может быть, оркестратор закрыл его в ответ на событие Asana, или пользователь в Asana – в любом случае, дальнейшее действие не требуется).

  Логируйте синхронизацию (например, "GitHub issue #42 closed -> marked Asana task 44556677889900 as completed").

- `action == "opened"` на issue: Если кто-то вручную открыл новый issue в GitHub, который не был из Asana, мы можем не хотеть создавать задачу Asana (интеграция может быть one-way из Asana в GitHub только). Prompt не требует синхронизации GitHub -> Asana для новых issues, поэтому мы вероятно игнорируем события открытия issue (если не нужно расширение). Мы можем просто логировать или игнорировать события открытия issue, если issue не в нашем отображении (или возможно создать задачу Asana, если нужно, но это вне указанной области).

- `action == "reopened"` на issue: Если issue переоткрыт и он отображает задачу Asana, которая завершена, мы можем рассмотреть пометку задачи Asana как незавершённой (Asana поддерживает пометку завершённой задачи незавершённой). Это потребует `PUT /tasks/{id}` с `{"data": {"completed": false}}`. Это хорошо иметь для поддержания consistency. Реализуйте, если время позволяет: когда issue переоткрыт, проверьте отображение и если задача Asana завершена, пометьте её как не завершённая. (Asana вебхук также будет отправлять событие `completed` change в этом случае – который наш обработчик Asana будет интерпретировать как переоткрыт, если `new_value=false` – поэтому оба вебхука теоретически могут инициировать друг друга. Будьте осторожны, чтобы избежать infinite loop, может быть, не реагируя, если мы знаем, что изменение было инициировано нашим собственным действием. Один способ – это сохранить, кто вызвал обновление, или добавить флаг в БД, что мы его переоткрыли.)

**События Pull Request**: События `pull_request` происходят при открытии PR, закрытии (слитом или нет) и т.д. Ключевой сценарий:

- Когда PR слит, GitHub будет инициировать событие `pull_request` с `action == "closed"` и в payload `pull_request.merged` будет `true`. Часто слияние PR, имеющего "Closes #<issue>" в его описании, автоматически закроет issue и инициирует событие `issues: closed`. Поэтому самый простой path: полагаться на событие закрытия issue для обработки пометки задачи Asana завершённой.

- Однако, для безопасности, оркестратор может также слушать события `pull_request`: Если PR слит и он ссылается на задачу Asana напрямую (например, имя ветки или заголовок PR имеет ID задачи Asana, или описание имеет ссылку), мы можем хотеть пометить задачу завершённой. Это более продвинутый парсинг. Учитывая наш дизайн, где каждая задача Asana соответствует GitHub issue, нормальный flow: PR merge -> issue закрывается -> наш обработчик issue помечает Asana done. Поэтому нам может не понадобиться явно обрабатывать события PR для закрытия задач.

- Мы можем использовать события PR для отслеживания прогресса (например, если PR открыт для issue, возможно обновить статус задачи Asana или прикрепить ссылку PR где-то). Это хорошо, но опционально. Минимальный approach: когда PR открыт, проверьте, связан ли он с issue, который отображает Asana, и если да, опубликуйте комментарий в Asana типа "Development started: PR #x opened". Это требует парсинга PR (например, проверить, если описание PR говорит "Fixes #42"). Это выходит за пределы основных требований, хотя.

На данный момент, убедитесь, что как минимум, слияния PR приводят к завершению задачи через событие закрытия issue.

**Событие Ping**: GitHub будет отправлять событие `ping`, когда вебхук создан для тестирования соединения. Обработчик должен просто ответить 200 на pings и возможно логировать setup хука (payload имеет сообщение `zen`). Никакое действие не требуется.

#### c. Ответ на события GitHub

Аналогично Asana, обработчик вебхука GitHub должен ответить быстро. Практически GitHub позволяет до 10 секунд для ответа. Наши действия (закрытие issues или пометка задач завершёнными) вовлекают внешние API-вызовы, которые могут занять несколько секунд. Лучше признать вебхук первым, затем выполнить асинхронную работу:

- Например, ответьте `res.status(200).send('OK')` как только событие признано и сигнатура верифицирована.
- Затем, в отдельной async функции или `setImmediate`, выполните логику (закрытие issue или завершение задачи). Таким образом GitHub не ждёт. Если работа не удаётся, мы можем обработать логику retry на нашей стороне (GitHub будет retry вебхуки при failure status codes, но поскольку мы уже ответили 200, мы берём на себя ответственность обработать любые ошибки с нашими API-вызовами внутренне).

#### d. Закрытие GitHub Issues через API (из событий Asana)

Когда событие завершения задачи Asana получено (это означает, что вероятно код был завершён извне или задача была закрыта PM), мы хотим закрыть GitHub issue. Оркестратор может вызвать GitHub's Update an issue API: `PATCH /repos/{owner}/{repo}/issues/{issue_number}` с `{"state": "closed"}` в JSON-теле. Опционально укажите `"state_reason": "completed"` для указания причины (один из "completed", "not_planned" и т.д. – "completed" подходит нашему сценарию task done). Это закроет issue. Используйте PAT для auth.

Пометьте в БД, что issue/task закрыты, чтобы избежать повторения действий.

## REST API оркестратора

Предоставьте набор REST endpoints для мониторинга статуса оркестратора и запуска действий вручную. Эти будут типично protected (как минимум не публично объявлены), потому что они могут изменять данные. Рассмотрите требование API ключа или basic auth для этих, или ограничение по IP, если на private network.

Безопасность важна, поскольку эти могут создавать issues или задачи.

**Возможные endpoints (все с префиксом, например, `/api` или `/orchestrator` для ясности):**

- **GET /health** – Возвращает простой статус сервиса (например, `{"status":"ok","uptime":12345}`). Это для мониторинга или health checks load balancer. Должен выполнить быструю self-check (типа можно lightweight DB query) и ответить. Никакой чувствительной информации здесь.

- **GET /tasks** – Список текущих задач и их статусов. Это может получить из БД список всех `task_mappings` с полями вроде имя задачи Asana, ID Asana, номер GitHub issue, статус (open/closed на каждой стороне). Это может быть read-only для мониторинга. Опционально поддержите query параметры для фильтрации (например, `?status=open`). Это помогает быстро увидеть, какие задачи outstanding или если какие-то mismatches (типа issue open, в то время как task завершена, указывая sync miss).

- **POST /tasks/sync** (или `/trigger`) – Запуск ручного действия синхронизации. Например, это может принять JSON-тело вроде `{"asana_task_gid": "1234567890"}` и будет force-create GitHub issue для этой задачи, если ещё не присутствует. Use case: если вебхук был down и некоторые задачи были созданы в промежутке, оператор мог вручную инициировать sync для этих задач. Endpoint будет:

  - Валидировать, что `asana_task_gid` предоставлен и это числовая строка.
  - Проверить, если это уже в таблице отображений; если да, вернуть может быть 200 с информацией "already synced".
  - Если нет, вызвать Asana API для получения деталей задачи, затем создать GitHub issue как per normal flow. Сохранить отображение.
  - Ответить с результатом (issue создан или ошибка). Это по сути выполняет, что автоматический вебхук бы сделал, но on-demand.

- **POST /tasks/:id/close** (опционально) – Вручную пометить задачу завершённой и закрыть соответствующий issue, или vice versa. Например, если задача Asana была закрыта, но GitHub issue не закрылся (может быть, GitHub токен был временно invalid), это может быть использовано для retry закрытия issue. Или если GitHub issue был неправильно закрыт, admin может переоткрыть via API. Однако, это может не быть нужно, если вебхуки reliable. Это более recovery endpoint.

Если реализуете write endpoints вроде выше, убедитесь в аутентификации. Как минимум, требуйте secret token заголовок или basic auth, чтобы случайные internet пользователи не могли инициировать создание issues или закрытия. Это может быть такой же простой, как переменная окружения `ADMIN_API_TOKEN` и проверка `req.headers['authorization']` или query param для этого токена.

Все API endpoints должны возвращать JSON. Используйте правильные HTTP status codes: 200 для успеха, 4xx для client errors (например, отсутствующие параметры), 500 для server errors/exceptions. Включите полезные сообщения в JSON ответ.

## Логирование и обработка ошибок

### Логирование

Реализуйте comprehensive логирование для отслеживаемости:

- Логируйте конфигурацию запуска: например, "Server listening on port X, connecting to DB host Y, monitoring Asana project Z and GitHub repo W." (Но избегайте логирования чувствительной информации типа токенов или секретов.)

- Для каждого события вебхука (Asana или GitHub) полученного, логируйте как минимум summary: тип события, релевантные IDs. Для Asana, например, "Asana event: task 44556677889900 added" или "Asana event: task 44556677889900 completed". Для GitHub, например, "GitHub event: issue #42 closed by userX" или "GitHub event: pull_request #10 merged".

- Логируйте действия, выполненные как результат: "Created issue #42 for Asana task …", "Closed issue #42 (PR merged) marking Asana task complete", "Marked task … incomplete (issue reopened)" и т.д. Включите IDs для корреляции с внешними системами.

- Логируйте предупреждения или anomalies: например, "Received Asana event for unknown task (not in project?) gid=… skipping" или "GitHub issue closed but no mapping found – ignoring".

- Логируйте ошибки из внешних API-вызовов: если вызов Asana API не удаётся (сеть или 4xx ошибка), логируйте HTTP status и ответ (но опять же, не логируйте auth token). Аналогично для GitHub API failures. Это поможет отладке (например, если мы получим 404, может быть ресурс уже был удалён и т.д.).

Рассмотрите использование structured логирования library (типа Winston или Pino) для лучшего вывода (с уровнями info/debug/error). Как минимум, `console.log` / `console.error` вызовы нормальны.

### Обработка ошибок и Retries

- Если вызов GitHub API не удаётся due to rate limiting (HTTP 403 с info rate limit) или transient ошибка, реализуйте simple retry с backoff. Аналогично для Asana (хотя rate limits Asana generous, но сетевые issues могут случиться). Вы можете проверить ответ headers для GitHub's `X-RateLimit-Remaining` и `Retry-After` если нужно, но более простой approach: catch error, wait несколько секунд, try опять.

- Если DB query не удаётся, логируйте это и может быть try переконнектиться, если соединение было потеряно. Pool `pg` должен обрабатывать reconnections, но вы можете слушать pool errors (например, `pool.on('error', ...)` для catch unexpected disconnections).

- Wrap обработку вебхука в try/catch. Если обработка не удаётся после отправки 200 ответа (поскольку мы делаем async), мы должны обработать это внутренне: может быть пометить отображение как нуждающееся внимания (или инициировать alert). Мы не хотим потерять sync silently. Логирование ошибок и может быть отправка email или другого alert может быть сконфигурирована, если критично.

## Соображения безопасности

- **Webhook Secrets**: Мы уже covered верификацию HMAC сигнатур для обоих Asana и GitHub – это mandatory для безопасности. Никогда не отключайте checks сигнатуры. Держите секреты safe (не в source code, preferably в env vars или secure vault). Rotate их, если нужно (например, если секрет был скомпрометирован, сгенерируйте новый и обновите вебхук).

- **Аутентификация**: Не экспозируйте endpoints мониторинга/trigger без auth. Как минимум, требуйте custom header или token. Эти endpoints могут изменять tasks/issues, поэтому ограничьте доступ.

- **Least Privilege**: Используйте отдельные tokens с минимальными scopes. Asana PAT должен иметь доступ только к релевантным workspace/project. GitHub token должен ideally быть Fine-Grained PAT scoped к единственному repo и только нужным разрешениям (Issues и webhooks). Если возможно, используйте GitHub App installation token вместо user PAT для лучшего security control.

- **Валидируйте Payloads**: После верификации сигнатур, также валидируйте структуру content payload. Например, проверьте, что `payload.issue` существует при обработке event issues и т.д. (Это охраняет от unexpected payloads или future changes.) Как рекомендовано GitHub, убедитесь, что required fields присутствуют перед trust к данным. В нашем случае, если `payload.issue.number` отсутствует, логируйте и пропустите скорее, чем выбрасывайте.

- **Предотвратите spoofed запросы**: Оба Asana и GitHub вебхуки используют сигнатуры для аутентификации source, который мы реализуем. Дополнительно, serve вебхук endpoints через HTTPS только (no plain HTTP), для предотвращения Man-in-the-Middle tampering.

- **Replay attacks**: Attacker мог бы re-send старый payload с valid сигнатурой (в пределах short time window) – для mitigate replay, Asana предлагает использование timestamps в payload (хотя Asana payload включает `created_at` per event которые мы могли бы track). GitHub включает unique delivery ID; мы keep track processed `X-GitHub-Delivery` IDs (например, в memory set или DB) для избежания обработки same delivery twice. Это mostly concern если someone перехватит и re-play traffic; с HMAC и HTTPS, risk низкий, но для completeness мы можем реализовать idempotency check используя delivery IDs (store recent ones для, say, 5-10 минут).

- **IP Allowlisting**: GitHub webhook IP ranges могут быть allow-listed на server firewall, если нужно (GitHub предоставляет список source IPs), и аналогично Asana может приходить из AWS ranges. Это optional extra layer – signature check типично sufficient.

- **Request Size/Rate**: Endpoints должны enforce max body size (для предотвращения кого-то отправляющего huge payloads для exhaust memory) – хотя Asana/GitHub payloads reasonably sized. Также реализуйте simple rate limiting на вебхук routes (например, если somehow endpoints хитом excessively, может быть используя in-memory counter или library), хотя опять же, sources known platforms которые usually не спамают beyond их event rates.

## Заключительные заметки

Следуя этой спецификации, drawn непосредственно из официальной документации Asana и GitHub API (с exact параметрами и expected behaviours) – включая proper handshake handling, сигнатурную верификацию для безопасности (HMAC-SHA256), правильное использование API для создания issues и обновления статуса завершения задачи – AI agent (OpenCode) должен быть в состоянии реализовать robust orchestrator сервис. Все критические детали такие как HTTP headers (например, `X-Hook-Secret`, `X-Hook-Signature`, `X-Hub-Signature-256`), типы полей и значения (например, `"completed": true/false` в task data), и примеры структур payload были предоставлены для исключения ambiguity. Результатом должен быть production-ready Node.js backend, который может быть развёрнут и запущен, achieving seamless интеграцию: когда задачи создаются или обновляются в Asana, соответствующие GitHub issues создаются или обновляются; когда PRs сливаются или issues закрываются в GitHub, соответствующие задачи Asana отмечаются завершёнными – всё это происходит автоматически через надёжную обработку вебхуков и API-вызовов.
